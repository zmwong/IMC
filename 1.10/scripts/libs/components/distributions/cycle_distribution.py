#!/usr/bin/env python
# /****************************************************************************
# INTEL CONFIDENTIAL
# Copyright 2017-2025 Intel Corporation.
# This software and the related documents are Intel copyrighted materials,
# and your use of them is governed by the express license under which they
# were provided to you ("License"). Unless the License provides otherwise,
# you may not use, modify, copy, publish, distribute, disclose or transmit
# this software or the related documents without Intel's prior written
# permission. This software and the related documents are provided as is,
# with no express or implied warranties, other than those that are expressly
# stated in the License.
# -NDA Required
# ****************************************************************************/
# pylint: disable=line-too-long
# -*- coding: utf-8 -*-
"""
This module defines a command generation mechanism that fills the list cycling
through the list of available LPUs (Logical Processing Units).
"""

from scripts.libs.components.distributions.abstract_distribution import (
    AbstractDistribution,
)
from itertools import cycle
from scripts.libs.utils import numa
from scripts.libs.utils import mem
from scripts.libs.components.os_system.numa_generation import NumaHandler
from scripts.libs.loggers.log_manager import (
    LogManager,
    LogManagerThread,
)


class CycleDistribution(AbstractDistribution):
    """
    A cycle-based implementation of the command distribution.

    This class defines a command generation mechanism that uses a cycle
    to assign commands to the available LPUs.

    Attributes:
        tool_manager (object): An object responsible for managing tool-specific data and operations.
    """

    def generate_commands(self):
        """
        Generates commands by cycling through LPUs or NUMA nodes.

        This method generates commands based on the available LPUs or NUMA nodes.
        If LPUs are provided, it calculates the available memory, determines the
        memory per instance, and ensures the block size provides optimal coverage.
        Commands are then generated by cycling through the LPUs and expanding the
        command list to the required size. If NUMA nodes are used, the process is
        repeated for each NUMA node.

        Returns:
            list: A list of generated commands.

        Raises:
            ValueError: If the available memory cannot be determined.

        Example:
            If LPUs are provided:
                - Memory is divided among LPUs.
                - Commands are generated by cycling through LPUs.

            If NUMA nodes are used:
                - Memory is divided among LPUs in each NUMA node.
                - Commands are generated for each NUMA node.

        Disclaimer:
            This function assumes that the memory usage percentage and block size
            are correctly configured in the parsed arguments.
        """
        commands_list = []

        numa_lpus = getattr(
            self.tool_manager.tool_data.parsed_args, "numa", {}
        ).items()
        if self.tool_manager.tool_data.parsed_args.lpus:
            lpu_cycle = cycle(self.tool_manager.tool_data.parsed_args.lpus)
            lpu_count = len(self.tool_manager.tool_data.parsed_args.lpus)
            available_mem = mem.get_available_mem(
                self.tool_manager.tool_data.parsed_args.mem_use,
                getattr(
                    self.tool_manager.tool_data.parsed_args, "target", None
                ),
            )
            if not available_mem:
                raise ValueError(
                    "Unable to determine how much memory to use because "
                    + "no usable memory was found."
                )
            mem_per_instance = float(available_mem / lpu_count)
            # Check to make sure the block size has the best coverage
            if not self.tool_manager.tool_data.parsed_args.blk_size:
                self.tool_manager.tool_data.parsed_args.blk_size = (
                    mem.check_blk_sz(
                        mem_per_instance,
                        self.tool_manager.tool_data.parsed_args.blk_size,
                    )
                )
            blk_size_str = f"block size of {self.tool_manager.tool_data.parsed_args.blk_size} bytes"
            LogManager().log(
                "SYS",
                LogManagerThread.Level.INFO,
                f"Using {self.tool_manager.tool_data.parsed_args.mem_use}% of available memory, with a {blk_size_str}.",
            )
            for test_case in self.expand_cmd_list(
                self.tool_manager.tool_data.parsed_args.xml_path, lpu_count
            ):
                commands_list.append(
                    self.tool_manager.generation_function(
                        test_case, mem_per_instance, next(lpu_cycle)
                    )
                )
        else:
            for numa_num, lpus in numa_lpus:
                free_mem = numa.get_node_free_mem(numa_num)
                mem_per_instance = float(
                    (
                        free_mem
                        * self.tool_manager.tool_data.parsed_args.mem_use
                        * 0.01
                    )
                    / len(lpus)
                )
                if not self.tool_manager.tool_data.parsed_args.blk_size:
                    self.tool_manager.tool_data.parsed_args.blk_size = (
                        mem.check_blk_sz(
                            mem_per_instance,
                            self.tool_manager.tool_data.parsed_args.blk_size,
                        )
                    )
                blk_size_str = f"block size of {self.tool_manager.tool_data.parsed_args.blk_size} bytes"
                LogManager().log(
                    "SYS",
                    LogManagerThread.Level.DEBUG,
                    "Using %.2f%% of available memory, with a %s.",
                    self.tool_manager.tool_data.parsed_args.mem_use,
                    blk_size_str,
                )
                lpu_cycle = cycle(lpus)
                for test_case in self.expand_cmd_list(
                    self.tool_manager.tool_data.parsed_args.xml_path, len(lpus)
                ):
                    numa_handler = NumaHandler(self.tool_manager)
                    commands_list.append(
                        numa_handler.generate_command(
                            test_case,
                            mem_per_instance,
                            next(lpu_cycle),
                            numa_num,
                        )
                    )

        return commands_list
